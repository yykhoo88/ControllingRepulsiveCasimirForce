Copyright 2009 The MathWorks, Inc.

Overview of functions:

    Generating wavefunctions :
    
        * calculateHydrogenicWavefunction()
            Used to evaluate a specified wavefunction over a grid. One has a
            choice of either passing in the grid parameters, or letting the
            function calculate them automatically, using
            calculateHydrogenicWavefunctionBounds().
        
        * generateWavefunctionList()
            Used to generate a structure containing multiple wavefunctions.
            One passes in lists of possible values for N, L and M, and all valid
            state described by permutations of these lists are evaluated.
    
    
    Resizing / Manipulating wavefunctions :
    
        * resizeWavefunctionGrid()
            Takes a list of wavefunctions on different grids and interpolates
            them onto a common grid.
        
        * findRadialMaximum()
            Finds the approximate upper bound on the wavefunction value as a
            function of radius. This is called by functions such as
            findWavefunctionsBoundingRadius()
        
        * findWavefunctionsBoundingRadius()
            Calculates the bounding radius of one or two wavefunctions. In the
            case of two wavefunctions, it attempts to ensure that the returned
            bounding radius is such that all linear superpositions of the
            two wavefunctions descend below the given probability threshold
            before the bounding radius is reached. This is used to calculate the
            bounding box for all wavefunctions generated by a transition.
        
        * calculateHydrogenicWavefunctionBounds()
            Estimates the radial extent of a wavefunction from the wavefunctions
            quantum numbers. This is used to generate an a priori estimate of
            the grid size needed to reasonably represent a wavefunction before
            evaluating the wavefunction. It simply evaluates the radial part
            of the Schrodinger equation, and returns the radius at which the
            wavefunction is below a certain fraction of it's peak value.
        
        * autoThreshold()
            Estimate iso-surface thresholds for a wavefunction. The inner
            iso-surface value is taken as half the height of the largest maxima
            and the outer iso-surface value is taken as half the height of the
            smallest maxima. The only exception to this rule is if the smallest
            maxima is close to the size of the largest maxima, at which point
            the thresholds are set to 50% and 5% of the largest maxima.
    
    
    Physical calculations on wavefunctions :
    
        * dipoleMoment()
            Calculates the dipole moment between two wavefunctions. In the
            current revision of the code, this function is unused.
        
        * calculateTransitionalState()
            Given and initial and final wavefunctions, calculates the state at
            any given time in the transition
    
    
    Plotting wavefunctions :
    
        * plotPsi()
            Plots a given wavefunction, automatically choosing the thresholds
            and axis bounds if desired.
    
        * simplePlotPsi()
            Plots a given state with minimal complexity. The user passes in a
            string representing the state (of the form 'N(LName)M', e.g. '2p0'
            or '3d-2').
    
        * blochSpherePlot()
            Plots a Bloch sphere representation of a state, with optional
            plotting of the historical states.
        
        * animateTransition()
            Animates a transition between a given initial and final
            wavefunction.
        
        * simpleAnimateTransition()
            Animates a transition with minimal complexity. The user passes in
            strings representing the initial and final states (of the form 
            'N(LName)M', e.g. '2p0' or '3d-2') and the wavefunctions are
            generated, rescaled and animated automatically.
    
    
    Miscellaneous :
    
        * getPsiFromNLM()
            Searches for a state labelled with the given combination of N, L
            and M in a given wavefunction list. The wavefunction list should
            be of the form generated by generateWavefunctionList().
        
        * getPsiList()
            Searches for a .mat file containing a wavefunction list. If it is
            asked to look for the default list, and there is none, it will
            generate one using the default settings of
            generateWavefunctionList(). The last loaded wavefunction list is
            cached in a persistent variable.
        
        * isElectricDipoleTransition()
            Evaluates whether the electric dipole transition rules are met.
        
        * lookupLNomenclature()
            Returns a character representing the angular momentum state, e.g.
            L=0 -> 's', L=3 -> 'd'
        
        * parseStateLabel()
            Parses a state label of the form '3d-2' to integer N, L and M
            values.
        
        * zeroCrossings()
            Calculates the positive and negative zero crossings of an array.
            Used by calculateHydrogenicWavefunctionBounds() to find the local
            maxima.



GUI operation overview :

    * Initialisation :
        In the opening function, we setup various constant parameters and
        default parameters. We set various variables to there initial conditions
        and populate various GUI elements such as the state list boxes.
    
    * State selection :
        The core functions of the state selector / list box populator are
        iUpdateLList() and iUpdateMList(). These functions populate a list box
        with the allowed L or M values correspondent with the chosen N or N,L
        values. These functions also store (in the list box's UserData) a lookup
        table (referred to as possibleL / M) that maps the indicies of the
        elements in the list box to values of L/M that they refer to.
        When the user changes the selection in one of the state selection
        list boxes, the callback (say, for the final state N list box,
        selN2_Callback()) updates the list boxes below it in the heirarchy (in
        this case selL2 and selM2) and resets the animation.
    
    * Animation operation :
        iResetAnimation() is always called as soon as the selected wavefunction
        is changed. It loads the initial and final wavefunctions from the
        wavefunction list, and plots the first frame of the animation (the
        initial state). N.B. it does not rescale the wavefunctions onto the same
        grid - by holding off the rescale until the user starts the animation, 
        we increase the responsiveness of the GUI.
        When the user clicks on the 'start' button, iDisplayAnimation() is
        called, via the buttons callback (startstop_Callback()). This resizes
        the wavefunctions (if necessary) by calling iResizeWavefunctions, clears
        the plot history if the animation state has changed discontinously, and
        calls animateTransition.
